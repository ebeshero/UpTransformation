<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="schedule.rnc" type="application/relax-ng-compact-syntax"?>
<?xml-model href="schedule.sch" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<schedule>
    <day d="Monday, June 11">
        <title>XPath</title>
        <slot time="10:00:00">
            <title>Introduction to XPath in eXist-db and &lt;oXygen/&gt;</title>
            <act time="PT20M">
                <desc>Getting started with XPath and eXide</desc>
                <details>
                    <item>Open <link>http://newtfire.org:8338/exist/apps/eXide/index.html</link> (or
                        eXide within eXist-db on your own laptop, if you’ve installed it), click
                        “New XQuery”, and erase all content in the editing window. You’ll type your
                        XPath in the editing window and run it with the “Eval” button.</item>
                    <item>Learning XPath (and other languages, including XSLT, XQuery, Schematron)
                        means learning the …<examples>
                            <example>Vocabulary (e.g., the division operator in XPath is <code
                                    url="https://www.w3.org/TR/xpath-31/#id-arithmetic">div</code>,
                                not <code>/</code>)</example>
                            <example>Syntax (e.g., in XPath <emph>conditional expressions</emph>,
                                the <code url="https://www.w3.org/TR/xpath-31/#doc-xpath31-IfExpr"
                                    >if</code> test must be parenthesized and an <code>else</code>
                                is required: <code>if (condition) then 1 else ()</code>)</example>
                            <example>Function library (e.g., <code
                                    url="https://www.w3.org/TR/xpath-functions-31/#func-string-length"
                                    >string-length()</code> and <code
                                    url="https://www.w3.org/TR/xpath-functions-31/#func-count"
                                    >count()</code> are functions, but there is no
                                    <code>length()</code> or <code>len()</code> or
                                    <code>size()</code>)</example>
                        </examples></item>
                    <item>All XPath expressions return a <emph>sequence</emph>. Sequences may
                        contain <emph>nodes</emph> (elements, attributes, etc.), <emph>atomic
                        </emph>values (strings, numbers, etc.), or both. A sequence of one item is
                        nonetheless a sequence, as is an <emph>empty sequence</emph>. Nested
                        sequences are automatically flattened.<examples>
                            <example>Type a number and hit Eval. This is a one-item sequence that
                                consists of a single atomic value. Try integers and decimal numbers.
                                Try wrapping the number in parentheses.</example>
                            <example>Type a string (inside single or double quotes) and hit Eval.
                                This is a one-item sequence that consists of a single atomic value.
                                Try omitting the quotation marks. Try using curly quotation marks.
                                Try wrapping the string in parentheses.</example>
                            <example>Type empty parentheses and hit Eval. This is an empty
                                sequence.</example>
                            <example>Type multiple items of different types (numbers, strings),
                                separated by commas. Try wrapping them in parentheses. Try wrapping
                                them in multiple parentheses. Try removing the commas. This is a
                                multi-item sequence.</example>
                            <example>Try to type a nested sequence, e.g., <code>(1, 2, (3,
                                    4))</code>, and hit Eval. What result do you expect? What do you
                                get?</example>
                        </examples></item>
                </details>
            </act>
            <act time="PT35M">
                <desc>Simple XPath expressions</desc>
                <details>
                    <item>Review: strings and numbers (atomic values) are XPath expressions <examples>
                            <example><code>"Hi, Mom!"</code> (Strings are enclosed in single or
                                double quotation marks—straight, not curly)</example>
                            <example><code>1</code> (Numbers are not enclosed in quotation
                                marks)</example>
                            <example><code>1.0</code> (What should this return? <emph>lexical
                                    space</emph> and <emph>value space</emph>)</example>
                        </examples></item>
                    <item>Arithmetic expressions are XPath expressions<examples>
                            <example><code>1 + 1</code></example>
                            <example>Practice: <code>+</code>, <code>-</code>, <code>*</code>,
                                    <code>div</code>, <code>idiv</code>, <code>mod</code>
                                    (<code>/</code> is not division)</example>
                        </examples></item>
                    <item>XPath library functions (with no arguments) are XPath expressions<examples>
                            <example><code
                                    url="https://www.w3.org/TR/xpath-functions-31/#func-current-date"
                                    >current-date()</code></example>
                            <example><code
                                    url="https://www.w3.org/TR/xpath-functions-31/#func-current-time"
                                    >current-time()</code></example>
                            <example><code
                                    url="https://www.w3.org/TR/xpath-functions-31/#func-current-dateTime"
                                    >current-dateTime()</code></example>
                        </examples></item>
                    <item>XPath library functions (with arguments) are XPath expressions<examples>
                            <example><code
                                    url="https://www.w3.org/TR/xpath-functions-31/#func-upper-case"
                                    >upper-case('dhsi')</code> (How many arguments, and of what
                                type?)</example>
                            <example><code
                                    url="https://www.w3.org/TR/xpath-functions-31/#func-concat"
                                    >concat('Curly', 'Larry', 'Moe')</code> (How many arguments, and
                                of what type?)</example>
                            <example><code
                                    url="https://www.w3.org/TR/xpath-functions-31/#func-count"
                                    >count(('Curly', 'Larry', 'Moe'))</code> (Why two sets of
                                parentheses? Hint: How many arguments, and of what type?)</example>
                            <example>Function <emph>signatures</emph> and <emph>cardinality</emph>:
                                    <code>count($items as item()*) as xs:integer</code></example>
                        </examples>
                    </item>
                    <item>Nested XPath library functions and operations are XPath expressions. Read
                        them from the inside out<examples>
                            <example><code url="https://www.w3.org/TR/xpath-functions-31/#func-max"
                                    >max((1 + 2, 10 div 5, 6 * 0.2))</code> (Remember those two sets
                                of parentheses?)</example>
                            <example><code
                                    url="https://www.w3.org/TR/xpath-functions-31/#func-translate"
                                    >translate(upper-case('Hi, Mom!'),'AEIOU','xxxxx')</code> (How
                                is this different from <code>upper-case(translate('Hi,
                                    Mom!','AEIOU','xxxxx'))</code>?)</example>
                            <example><code
                                    url="https://www.w3.org/TR/xpath-functions-31/#func-format-dateTime"
                                    >format-dateTime(current-dateTime(),'[h].[m01][Pn] on [FNn],
                                    [D1o] [MNn]')</code></example>
                        </examples></item>
                    <item>Nested functions are hard to read. Use the <emph
                            url="https://www.w3.org/TR/xpath-31/#id-arrow-operator">arrow
                            operator</emph> (<code>=&gt;</code>) instead<examples>
                            <example><code>upper-case('Hi, Mom!') =>
                                    translate('AEIOU','xxxxx')</code></example>
                            <example><code>current-dateTime() => format-dateTime('[h].[m01][Pn] on
                                    [FNn], [D1o] [MNn]')</code></example>
                        </examples></item>
                    <item>Path expressions may span multiple lines (try it with the examples above),
                        that is, new-line and space have the same meaning</item>
                </details>
            </act>
            <act time="PT20M">
                <desc>XPath in &lt;oXygen/&gt;</desc>
                <details>
                    <item>Launch &lt;oXygen/&gt; editor, hit <q>Ctrl+u</q> (Windows) or <q>Cmd+u</q>
                        (MacOS), copy and paste the string
                            <q>http://newtfire.org:8338/exist/apps/shakespeare/data/ham.xml</q>, and
                        hit <q>OK</q>. (Backup copy at
                            <q>https://raw.githubusercontent.com/ebeshero/UpTransformation/master/data/ham.xml</q>.)
                        This is a copy of <emph>Hamlet</emph> with TEI markup.</item>
                    <item>Set the dropdown in the upper left to <q>XPath 3.0</q>. (This widget is
                        called the <emph
                            url="https://www.oxygenxml.com/doc/versions/20.0/ug-editor/topics/xpath-console.html"
                            >XPath Toolbar</emph>.) Enter some XPath expressions (from above, such
                        as <code>1 + 1</code>). Limited to one line; hit <q>Enter</q> to run the
                        expression. The XPath Toolbar works only if you have an XML document open in
                        &lt;oXygen/&gt;, even if you aren’t using the document in your XPath
                        expression.</item>
                    <item>Go to Window → Show View → XPath/XQuery Builder. Set the dropdown in the
                        upper left to <q>XPath 3.0</q>. Enter some XPath expressions. May span
                        multiple lines; <q>Enter</q> for a new line. To run, hit <q>Ctrl+Enter</q>
                        (Windows) or <q>Cmd+Enter</q> (MacOS), or click the red right-pointed
                        triangle.</item>
                </details>
            </act>
            <act time="PT25M">
                <desc>XPath path expressions</desc>
                <details>
                    <item>An XPath <emph>path expression</emph> is a sequence of steps, each of
                        which proceeds from one node (called the <emph>context node</emph>) to a
                        sequence of zero (!) or more others. It returns the results in document
                        order (order of start tags). (Details at Kay 1227)</item>
                    <item>Sample XPath path expression: <code>/TEI/text/body/div</code>: start at
                        the document node, then navigate to a sequence of all its
                            <code>&lt;TEI&gt;</code> children. For each of those, navigate to all of
                        their <code>&lt;text&gt;</code> children, then to their
                            <code>&lt;body&gt;</code> children, and then to their
                            <code>&lt;div&gt;</code> children.</item>
                    <item>XPath steps are separated by single slashes (<code>/</code>).</item>
                    <item>An XPath expression that begins with a slash (<code>/</code>) starts at
                        the <emph>document node</emph>; this is an <emph>absolute path</emph>. Any
                        other XPath expression starts at the current context; this is a
                            <emph>relative path</emph>.</item>
                    <item>It is not an error to ask for something that doesn’t exist; it just
                        returns an empty sequence.</item>
                    <item>With <emph>Hamlet</emph> open and selected, go to the XPath Toolbar or
                        XPath Builder and try the following examples. Click on some of the results
                        in the lower panel:<examples>
                            <example><code>/TEI/teiHeader/fileDesc/titleStmt/title</code> (returns 1
                                    <code>&lt;title&gt;</code> element)</example>
                            <example><code>/TEI/text/body/div</code> (returns 5
                                    <code>&lt;div&gt;</code> elements)</example>
                            <example><code>/TEI/teiHeader/fileDesc/titleStmt/info</code> (returns no
                                results; this is not an error)</example>
                            <example><code>/TEI/teiHeader/fileDesc/title Stmt/title</code> (throws
                                in an XPath path expression)</example>
                        </examples></item>
                    <item>Namespaces matter in Real Life (XSLT, XQuery, Schematron), but the
                        &lt;oXygen/&gt; XPath Toolbar and XPath Builder take care of them for you
                        behind the scenes. eXide does not; you have to specify namespaces in
                        eXide.</item>
                </details>
            </act>
            <act time="PT20M">
                <desc>XPath path steps</desc>
                <details>
                    <item>Path steps move along axes: <code>child::</code>, <code>parent::</code>,
                            <code>descendant::</code>, <code>ancestor::</code>,
                            <code>preceding-sibling::</code>, <code>following-sibling::</code>, etc.
                        See:
                            <link>http://dh.obdurodon.org/introduction-xpath.xhtml#xpath_axes</link>.</item>
                    <item>Axes are specified with a double colon, e.g., <code>descendant::div</code>
                        matches all <code>&lt;div&gt;</code> descendants of the current context
                        node. There are two common shortcut notations<examples>
                            <example>The default is the <emph>child</emph> axis, so
                                    <code>/TEI/teiHeader</code> is synonymous with
                                    <code>/child::TEI/child::teiHeader</code>. Use the
                                shorthand.</example>
                            <example><code>//</code> is shorthand for
                                    <code>/descendant-or-self::</code>, so <code>/TEI//div</code>
                                finds all of the <code>&lt;div&gt;</code> elements that are
                                descendants of the <code>&lt;TEI&gt;</code> root element, that is,
                                anywhere in the document. The document node has a descendant axis,
                                too: <code>//div</code>. Be careful with this one!</example>
                        </examples>
                    </item>
                    <item>Each path step returns a sequence of zero or more context nodes for the
                        next path step. Only the final path step is permitted to return something
                        other than a node. Why?</item>
                    <item>The end of a path expression may return nodes or atomic values<examples>
                            <example><code>//body/div/count(descendant::sp)</code> navigates from
                                the document node to all of the acts in the play and then returns a
                                count of the speeches in each act</example>
                            <example>What’s wrong with <code>//body/div/count(//sp)</code>?
                                    <answer>The leading double slash resets the current context to
                                    the document node, and selects all <code>&lt;sp&gt;</code>
                                    elements in the entire document, instead of just the individual
                                    act.</answer></example>
                        </examples></item>
                    <item><code>*</code> matches any element<examples>
                            <example><code>/TEI/teiHeader/*</code> matches all child elements of the
                                    <code>&lt;teiHeader&gt;</code></example>
                        </examples></item>
                    <item><code>..</code> matches the parent node of the current context node. That
                        is, it’s shorthand for <code>parent::*</code><examples>
                            <example><code>//stage/..</code> matches the parent nodes of all
                                    <code>&lt;stage&gt;</code> elements</example>
                        </examples></item>
                    <item>Find the acts (<code>&lt;div&gt;</code> children of
                            <code>&lt;body&gt;</code>) in <emph>Hamlet</emph>
                        <answer>
                            <code>//body/div</code>
                        </answer></item>
                    <item>Find the stage directions (<code>&lt;stage&gt;</code>) in
                            <emph>Hamlet</emph>
                        <answer>
                            <code>//stage</code>
                        </answer></item>
                    <item>Find the <code>&lt;stage&gt;</code> children of <code>&lt;div&gt;</code>
                        elements (but not other <code>&lt;stage&gt;</code> elements) in
                            <emph>Hamlet</emph>
                        <answer>
                            <code>//div/stage</code>
                        </answer></item>
                    <item>Find the parents of the stage directions in <emph>Hamlet</emph>
                        <answer>
                            <code>//stage/..</code> or <code>//stage/parent::*</code>
                        </answer></item>
                    <item>Find the <code>&lt;div&gt;</code> parents of the stage directions in
                            <emph>Hamlet</emph>, but not other parents <answer>
                            <code>//stage/parent::div</code>
                        </answer></item>
                </details>
            </act>
        </slot>
        <slot time="13:15:00">
            <title>Exploring document structures and data with XPath</title>
            <act time="PT25M">
                <desc>XPath functions for strings</desc>
                <details>
                    <item><code>concat()</code>
                        <examples>
                            <example>
                                <code>concat('Curly','Larry','Moe')</code></example>
                            <example><code>concat('Curly is #', 1)</code></example>
                            <example>Or use the <emph>concatenation operator</emph>: <code>'Curly is
                                    #' || 1</code></example>
                            <example>What’s wrong with <code>concat(//speaker)</code>? <answer>The
                                    arguments to <code>concat()</code> must be two or more
                                    individual atomic (or atomizable) items, and
                                        <code>//speaker</code> is a sequence.</answer></example>
                        </examples>
                    </item>
                    <item><code>string-join()</code><examples>
                            <example><code>string-join(( 'Curly', 'Larry', 'Moe'), ',
                                ')</code></example>
                            <example><code>string-join(//speaker, ', ')</code></example>
                            <example><code>string-join(//speaker)</code> Why does this work when
                                    <code>concat(//speaker)</code> didn’t? <answer>The first
                                    argument to <code>string-join()</code> is a sequence. All
                                    arguments to <code>concat()</code> must be atomic or
                                    atomizable.</answer></example>
                        </examples></item>
                    <item><code>string-length()</code><examples>
                            <example><code>string-length('Curly, Larry, and Moe')</code></example>
                        </examples></item>
                    <item><code>lower-case()</code>, <code>upper-case()</code>
                        <examples>
                            <example><code>lower-case('Curly, Larry, and Moe')</code></example>
                        </examples></item>
                    <item><code>normalize-space()</code><examples>
                            <example><code>normalize-space(' Curly, Larry, Moe ')</code></example>
                        </examples></item>
                    <item><code>substring-before()</code>, <code>substring-after()</code><examples>
                            <example><code>substring-before('Larry', 'r')</code> What if there’s
                                more than one?</example>
                            <example><code>substring-after('Larry', 'r')</code> What if there’s more
                                than one?</example>
                        </examples></item>
                    <item><code>substring()</code><examples>
                            <example><code>substring('Curly', 1, 2)</code> XPath starts counting
                                with 1 (not 0).</example>
                        </examples></item>
                    <item><code>contains()</code> Foreshadowing: This returns a Boolean
                            (<code>True</code> or <code>False</code>) value. How might this be useful?<examples>
                            <example><code>contains('Ophelia', 'ph')</code></example>
                            <example><code>//speaker/contains(., 'ph')</code> (the dot refers to the
                                current context item)</example>
                        </examples></item>
                </details>
            </act>
            <act time="PT25M">
                <desc>XPath functions for numbers</desc>
                <details>
                    <item><code>max()</code>, <code>min()</code>, <code>sum()</code>,
                            <code>avg()</code><examples>
                            <example><code>max((1, 2, 3))</code>, etc.</example>
                            <example>What happens when these are applied to strings? To a sequence
                                that mixes strings and numbers?</example>
                        </examples></item>
                    <item><code>ceiling()</code>, <code>floor()</code>
                        <examples>
                            <example><code>ceiling(3.141592653)</code></example>
                        </examples></item>
                    <item><code>round()</code><examples>
                            <example><code>round(3.141592653, 4)</code></example>
                        </examples></item>
                    <item><code>format-number()</code><examples>
                            <example><code>format-number(1, '#.000')</code></example>
                            <example><code>format-number(1, '#.###')</code></example>
                        </examples></item>
                    <item>Find the length in character count of each <code>&lt;speaker&gt;</code>
                        <answer><code>//speaker/string-length()</code> (why doesn’t
                                <code>string-length(//speaker)</code> work?)</answer></item>
                    <item>Find the length of longest speaker name
                                <answer><code>max(//speaker/string-length())</code></answer></item>
                </details>
            </act>
            <act time="PT15M">
                <desc>XPath functions for sequences</desc>
                <details>
                    <item><code>distinct-values()</code>
                        <examples>
                            <example><code>distinct-values(/TEI//speaker)</code></example>
                        </examples></item>
                    <item><code>count()</code><examples>
                            <example><code>count(('Curly', 'Larry', 'Moe',
                                'Curly'))</code></example>
                            <example><code>count(distinct-values(('Curly', 'Larry', 'Moe',
                                    'Curly')))</code></example>
                            <example><code>distinct-values(count(('Curly', 'Larry', 'Moe',
                                    'Curly')))</code></example>
                        </examples></item>
                    <item><code>sort()</code><examples>
                            <example><code>sort(//speaker)</code></example>
                            <example><code>sort(//speaker,(), function($item)
                                    {string-length($item)})</code></example>
                        </examples></item>
                    <item>How many <code>&lt;speaker&gt;</code> elements are there in
                            <emph>Hamlet</emph>?
                        <answer><code>count(//speaker)</code></answer></item>
                    <item>How many <emph>distinct</emph>
                        <code>&lt;speaker&gt;</code> elements are there in <emph>Hamlet</emph>?
                                <answer><code>count(distinct-values(//speaker))</code></answer></item>
                    <item>How many acts are there in <emph>Hamlet</emph>?
                                <answer><code>count(//body/div)</code></answer></item>
                    <item>How many scenes are there in <emph>Hamlet</emph>?
                                <answer><code>count(//div/div)</code></answer></item>
                    <item>What does <code>count(//div)</code> tell you about <emph>Hamlet</emph>,
                        and why is it unhelpful? <answer>It counts <code>&lt;div&gt;</code> elements
                            of different types together: acts, scenes, cast list.</answer></item>
                </details>
            </act>
            <act time="PT15M">
                <desc>Looking Stuff Up: XPath function signatures and cardinality</desc>
                <details>
                    <item>The <emph>function signature</emph> is the number and type of arguments it
                        accepts or requires</item>
                    <item><emph>Type error</emph>: <code>string-length(1.2345)</code></item>
                    <item><emph>Cardinality error</emph>:
                        <code>string-length(/TEI/speaker)</code></item>
                    <item>Why is <code>count(/TEI//speaker)</code> okay, while <code>count('Curly',
                            'Larry', 'Moe')</code> is broken?</item>
                    <item>The error message is your friend. Read it.</item>
                    <item>Mozilla Development Network (MDN):
                            <link>https://developer.mozilla.org/en-US/docs/Web/XPath</link></item>
                </details>
            </act>
            <act time="PT25M">
                <desc>XPath predicates</desc>
                <details>
                    <item><emph>Predicates</emph>, in square brackets after a path step,
                            <emph>filter</emph> the results</item>
                    <item>Numerical predicates<examples>
                            <example><code>//body/div[3]</code> matches the third
                                    <code>&lt;div&gt;</code> child of each <code>&lt;body&gt;</code>
                                element (same as <code>//body/div[position() eq 3]</code></example>
                            <example><code>//body/div[last()]</code> matches the last
                                    <code>&lt;div&gt;</code> child of each <code>&lt;body&gt;</code>
                                element (same as <code>//body/div[position() eq 3]</code></example>
                            <example>Numerical predicates count away from the context node<examples>
                                    <example><code>//sp/preceding-sibling::stage[1]</code> matches
                                        the first <code>&lt;stage&gt;</code> element before (but on
                                        the same hierarchical level as) each
                                        <code>&lt;sp&gt;</code></example>
                                    <example><code>//sp/ancestor[1]</code> is equivalent to
                                            <code>//sp/..</code></example>
                                </examples></example>
                        </examples></item>
                    <item>Predicates with node tests<examples>
                            <example><code>//stage[parent::div]</code> is equivalent to
                                    <code>//div/stage</code></example>
                        </examples></item>
                    <item>Predicates with functions<examples>
                            <example><code>//sp[speaker eq 'Ophelia']</code></example>
                        </examples></item>
                </details>
            </act>
            <act time="PT15M">
                <desc>Odds and ends</desc>
                <details>
                    <item>Three ways to apply a function to a sequence<examples>
                            <example>Explicit <code>for</code><examples>
                                    <example><code>for $speaker in /TEI//speaker return
                                            contains($speaker, 'ph')</code></example>
                                </examples></example>
                            <example>Implicit <code>for</code><examples>
                                    <example><code>/TEI//speaker/contains(., 'ph')</code></example>
                                </examples></example>
                            <example>Simple map (<code>!</code>)<!-- add URL --><examples>
                                    <example><code>/TEI//speaker ! contains(.,
                                        'ph')</code></example>
                                </examples></example>
                        </examples></item>
                    <item>Difference between simple map (<code>!</code>) and arrow (<code>=></code>) <examples>
                            <example><code>('Curly', 'Larry', 'Moe') => count()</code></example>
                            <example><code>('Curly', 'Larry', 'Moe') ! count(.)</code></example>
                        </examples></item>
                    <item>Concatenating nodes<examples>
                            <example><code>string-join()</code><examples>
                                    <example><code>string-join(( 'Curly', 'Larry', 'Moe'), ',
                                            ')</code></example>
                                    <example><code>concat(/TEI//speaker, ', ')</code> Why doesn’t
                                        this work?</example>
                                    <example><code>string-join(/TEI//speaker, ', ')</code> Use this
                                        instead</example>
                                </examples></example>
                        </examples></item>
                </details>
            </act>
            <act time="PT35M">
                <desc>Read and evaluate XML projects with XPath</desc>
                <details>
                    <item>Find all speeches (<code>&lt;sp&gt;</code>) by Ophelia
                                <answer><code>//sp[speaker eq 'Ophelia']</code></answer></item>
                    <item>Find all speeches in Act 2 by Ophelia
                                <answer><code>//body/div[2]//sp[speaker eq
                            'Ophelia']</code></answer></item>
                    <item>What types of elements can have stage directions
                            (<code>&lt;stage&gt;</code>) as children? (Hint: use the <code
                            url="https://www.w3.org/TR/xpath-functions-31/#func-name">name()</code>
                        function.)</item>
                    <item>Are there speeches that don’t any contain metrical lines
                            (<code>&lt;l&gt;</code>)? What kinds of elements they contain
                        instead?</item>
                    <item>What’s the difference between <code>//sp[@who="Hamlet"]/l[1]</code> and
                            <code>(//sp[@who="Hamlet"]/l)[1]</code>?</item>
                    <item>What XPath expressions will find the last stage direction in the entire
                        document? (Note: there should be only one!)</item>
                    <item>What XPath expression will find all speeches elements with more than 8
                        liness?</item>
                    <item>Building on your answer to the preceding question, what XPath expression
                        will tell you how many line children each of those speeches has?</item>
                    <item>Building on your answers to the preceding two questions, what XPath
                        expression will find the speakers of all speeches that have more than 8 line
                        subelements? What XPath expression will find the speakers of those lines
                        (with no duplication!)?</item>
                    <item>How long is the longest speech?</item>
                    <item>Building on your answer to the last question, who is the speaker of the
                        longest speech?</item>
                </details>
            </act>
        </slot>
    </day>
    <day d="Tuesday, June 12">
        <title>XPath and XQuery</title>
        <slot time="09:30:00">
            <title>XPath and XQuery in eXist-db</title>
            <act time="PT10M"><desc>Housekeeping: documents, collections, and namespaces</desc>
                <details>
                    <item>In the eXide window, click on the <q>New XQuery</q> tab. This brings up a window with <code>xquery version "3.1";</code> at the top.</item>
                    <item>Access a document with the XPath <code>doc()</code> function using its filepath address in eXist-db: <examples><example><code>doc('/db/apps/shakespeare/data/ham.xml')</code></example></examples>
                    </item>
                    <item>Access a collection (a directory containing XML files) with the X</item>
                    <item>Namespaces </item>
                </details>
            </act>
            <act time="PT30M">
                <desc>The seven types of nodes (and how to access them in eXist-db)</desc>
                <details>
                    <item><code>document()</code> (This node contains the root element, but sits
                        above it).</item>
                    <item><code>processing-instruction()</code> (This node includes things like
                        schema associations)</item>
                    <item><code>element()</code> (Review the anatomy of an element.) </item>
                    <item><code>text()</code> (This is not a function, but an actual node. <examples>
                            <example>Look at the difference between <code>text()</code> and two
                                functions that return text extracted from the tree:
                                    <code>string()</code> and <code>data()</code></example>
                            <example>Access <code>text()</code> in <emph>mixed content</emph> using
                                the <code>preceding-sibling::</code> and
                                    <code>following-sibling::</code> axes </example>
                        </examples></item>
                    <item><code>attribute()</code> (The attribute node has a special relationship to
                        its element on the <code>parent::</code> axis, but otherwise has no
                        relationship to other elements on the tree.) <examples>
                            <example><code>string()</code> function to retrieve the value in
                                eXist</example>
                        </examples>
                    </item>
                    <item><code>comment()</code>
                        <examples>
                            <example><code>&lt;!-- --&gt;</code></example>
                        </examples>
                    </item>
                    <item><code>namespace()</code> (XML documents can written in multiple
                        namespaces, and the namespace node lets us navigate them.) <examples>
                            <example>Navigate the namespaces of an XHTML and SVG document.
                            </example>
                        </examples>
                    </item>
                </details>
            </act>
            <act time="PT20M">
                <desc>Neglected XPath axes</desc>
                <details>
                    <item><code>preceding::</code> and <code>following::</code><examples>
                            <example>Find all the stage directions (marked in <code>&lt;stage&gt;</code> elements) that immediately precede spoken verse lines (marked in <code>&lt;l&gt;</code> elements) in <emph>Hamlet</emph>.
                                <answer>xquery version "3.1";
                                    declare namespace tei="http://www.tei-c.org/ns/1.0";
                                    doc('/db/apps/shakespeare/data/ham.xml')//tei:stage[preceding-sibling::tei:l]</answer>
                            </example>
                        </examples></item>
                    <item><code>self:: (.)</code> Often used in predicates. <examples>
                            <example>String functions: <code>matches(., '^[A-Z]')</code></example>
                        </examples></item>
                    <item><code>ancestor::</code>
                        <examples>
                            <example>Navigate a TEI document from a node in the
                                <code>&lt;text&gt;</code> to a corresponding node in the
                                <code>&lt;teiHeader&gt;</code>.</example>
                        </examples>
                    </item>
                </details>
            </act>
            <act time="PT30M">
                <desc> Don’t confuse XPath predicates with path steps. Scavenger Hunt Exercise to
                    review XPath syntax we have learned so far.</desc>
                <details>
                    <item>Exercise: Work with the Digital Mitford Site Index posted in eXist at
                            <link>/db/mitford/si.xml</link> or the official version at its external
                        location: <link>http://digitalmitford.org/si.xml</link> Can you find the
                        following [5 or 6 things to review what we have been teaching]. </item>
                </details>
            </act>
            <act time="PT30M">
                <desc>String Functions Intensive Unit: Regex in XPath</desc>
                <details>
                    <item><code>contains()</code> vs. <code>matches()</code></item>
                    <item><code>translate()</code> vs. <code>replace()</code></item>
                    <item><code>substring-before()</code> and <code>substring-after()</code> vs.
                            <code>tokenize()</code></item>
                </details>
            </act>
            <act time="PT30M">
                <desc>XPath in XQuery: Introducing Variables</desc>
                <details>
                    <item>Global variables and syntax, how to return their values in eXist-db</item>
                    <item><code>FLWOR</code> variables: <code>For</code>, <code>Let</code>,
                            <code>Where</code>, <code>Order by</code>, <code>Return</code></item>
                    <item>The simplest <code>FLWOR</code>: <code>Let</code> and <code>Return</code>
                        <examples>
                            <example>Retrieve whole elements</example>
                            <example>Retrieve only their text</example>
                        </examples>
                    </item>
                </details>
            </act>
        </slot>
        <slot time="13:15:00">
            <title>XQuery flow control</title>
            <act time="PT40M">
                <desc>Defining variables: XPath expressions with functions and predicates</desc>
                <details>
                    <item><code>FLWOR</code> Scavenger Hunt Exercise: Write FLWOR statements
                        mimicking/extending the previous Scavenger Hunt.</item>

                </details>
            </act>
            <act time="PT40M">
                <desc>XPath <code>for</code> loops; sequence and range variables
                    (&lt;oXygen/&gt;)</desc>
                <details>
                    <item><code>for $i in (sequence) return ...</code></item>
                    <item>Practice examples in &lt;oXygen/&gt; <examples>
                            <example>Use XPath builder window: for each of a set of keyed
                                attributes, return something associated with each one.</example>
                        </examples>
                    </item>

                </details>
            </act>
            <act time="PT40M">
                <desc><code>FLWOR</code> statements (XQuery in eXist-db): How <code>For</code>
                    works</desc>
                <details>
                    <item><code>For $i in $YourSequenceVariable</code> and iterative returns</item>
                    <item>The <code>$pos</code> variable: <code>For $i at $pos in
                            $YourSequenceVariable</code></item>
                    <item>Sorting and ordering: XPath <code>sort()</code> function: using this above
                        a for-loop, vs. the XQuery <code>Order by</code> statement inside a for-loop
                        to control the order of processing and returns.</item>
                    <item>Adding where to <code>FLWOR</code> with a for-loop to limit the
                        returns</item>
                    <item>Which is more efficient in XQuery: a predicate or <code>Where</code>?
                    </item>
                </details>

            </act>
            <act time="PT35M">
                <image size="icon"
                    alt="'To create a little flower is the labour of ages.' –William Blake, The Proverbs of Hell"
                    >flower.jpg</image>
                <desc>Putting it all together: FLWORs for pulling data</desc>
                <details>
                    <item>Text returns: combining strings into one result: <code>concat()</code> and
                            <code>string-join()</code></item>

                    <item>HTML returns: how to use curly braces to layer and activate XQuery in an
                        HTML file.</item>
                </details>
            </act>

        </slot>
    </day>
    <day d="Wednesday, June 13">
        <title>XPath and XSLT</title>
        <slot time="09:30:00">
            <title>Introduction to XPath in XSLT</title>
            <act time="PT40M">
                <desc>XSLT overview</desc>
                <details>
                    <item>XSLT (eXtensible Stylesheet Language Transformations) is an XML document
                        with special namespaced elements designed to process XML documents</item>
                    <item>Basic structure: <code>&lt;xsl:stylesheet&gt;</code> is the root element,
                        with <code>&lt;xsl:template&gt;</code> children.</item>
                    <item>A <emph>declarative programming language</emph>. Not written to be
                        executed in a line-by-line order. Template elements (or <emph>template
                            rules</emph>) do the work, but can be written in any order. </item>
                    <item>Templates match patterns: <code>&lt;xsl:template match="???"&gt;</code>:
                        The <code>@match</code> here is a special kind of XPath called an
                            <emph>XPath pattern</emph>, which could be found anywhere in the
                        document hierarchy. Note: It is inefficient for processing to write these
                        pattern expressions as we would an XPath search in the XPath Toolbar.</item>
                    <item>In each example below, look at the <code>@match</code> value: What should
                        the XPath pattern be matching in the source XML document? And how is this
                        XPath different from the way we write XPath in the XPath Toolbar? <examples>
                            <example><code>&lt;xsl:template match="div/head&gt;"</code>
                                <answer>Matches any <code>&lt;head&gt;</code> child of a
                                        <code>&lt;div&gt;</code> at any level of the XML hierarchy.
                                    In the XPath Toolbar, we have to start the expression with two
                                    leading forward slashes (<code>//</code>) to indicate we are
                                    looking <q>down</q> the tree from the document node.</answer>
                            </example>
                            <example><code>&lt;xsl:template match="div[count(descendant::p) gt
                                    1]&gt;"</code>
                                <answer>Matches any <code>&lt;div&gt;</code> element that contains
                                    multiple (more than one) <code>&lt;p&gt;</code> descendants. In
                                    the XPath toolbar, we must add <code>//</code> to the
                                    beginning.</answer>
                            </example>
                        </examples>
                    </item>
                    <item>Inside template rules, <code>&lt;xsl:apply-templates&gt;</code> drives the
                        selection of the next template rules to fire.
                            <code>&lt;xsl:apply-templates&gt;</code>
                        <emph>consumes</emph> the XML node matched in the template rule, and
                        determines that its children or other nodes in a set XPath relationship to
                        the template match will be processed. </item>
                    <item><code>xsl:apply-templates</code> with or without an <code>@select</code>: <code>@select</code> <q>prunes the tree</q> with a specific XPath expression that specifically identifies  which XML elements in the source document will be processed next. Without <code>@select</code>, all element contents are consumed and processed by default.</item>
                        <item>The XPath expression in <code>@select</code> is <emph>literal</emph> and defined by its relation to the node being matched by the template rule (in the <code>@match</code> on <code>xsl:template</code>. </item>
                    <item><code>xsl:apply-templates</code> with or without <code>@select</code>:
                            <code>@select</code>
                        <q>prunes the tree</q> with a specific XPath expression that specifically
                        identifies which XML elements in the source document will be processed next.
                        Without <code>@select</code>, all element contents are consumed and
                        processed by default.</item>
                    <item>The XPath expression in <code>@select</code> is <emph>literal</emph> and
                        defined by its relation to the node being matched by the template rule (in
                        the <code>@match</code> on <code>xsl:template</code>. </item>
                </details>
            </act>
            <act time="PT40M">
                <desc>Preparing to write XSLT in &lt;oXygen/&gt;</desc>
                <details>
                    <item>Namespaces and why they matter: <q>It’s always a namespace issue.</q> </item>
                </details>
            </act>
            <act time="PT40M">
                <desc>XSLT template matching and context nodes</desc>
            </act>
            <act time="PT30M">
                <desc>Identity transformation</desc>
            </act>
        </slot>
        <slot time="13:15:00">
            <title>Pushing and pulling</title>
            <act time="PT40M">
                <desc><code>&lt;xsl:apply-templates&gt;</code> and the <code>@select</code>
                    attribute</desc>
            </act>
            <act time="PT40M">
                <desc>XSLT push and pull processing</desc>
            </act>
            <act time="PT40M">
                <desc>When to use <code>&lt;xsl:value-of&gt;</code></desc>
            </act>
            <act time="PT35M">
                <desc>Comparing XSLT and XQuery</desc>
            </act>
        </slot>
    </day>
    <day d="Thursday, June 14">
        <title>XPath and Schematron</title>
        <slot time="09:30:00">
            <title>Using Schematron to constrain your markup</title>
            <act time="PT1H">
                <desc>Schematron overview</desc>
            </act>
            <act time="PT30M">
                <desc>XPath functions practice</desc>
            </act>
            <act time="PT1H">
                <desc>Grouping; looping over distinct values, mapping back to the tree</desc>
            </act>
        </slot>
        <slot time="13:15:00">
            <title>Writing Schematron with XPath function</title>
            <act time="PT2H35M">
                <desc>Lab session (sample materials provided, or work with your own data)</desc>
            </act>
        </slot>
    </day>
    <day d="Friday, June 15">
        <title>Taking stock</title>
        <slot time="09:30:00">
            <title>Review of XPath applications</title>
            <act time="PT1H30M">
                <desc>Review of XPath and its applications</desc>
            </act>
            <act time="PT1H">
                <desc>What next?</desc>
            </act>
        </slot>
    </day>
</schedule>
