<section xmlns="http://www.w3.org/1999/xhtml"><h1>Schedule</h1><p><button id="expand">Expand all</button> | <button id="collapse">Collapse
                all</button></p>
    <section>
        <h2>Monday, June 11: XPath</h2>
        <section><h3>Introduction to XPath in eXist-db and &lt;oXygen/&gt; (10:15 a.m.–12:00 p.m.)</h3><ul><li>Getting started with XPath and eXide (15 minutes; 10:15 a.m.–10:30 a.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li>Open <a href="http://newtfire.org:8338/exist/apps/eXide/index.html">http://newtfire.org:8338/exist/apps/eXide/index.html</a> (or
                        eXide within eXist-db on your own laptop, if you’ve installed it), click
                        “New XQuery”, and erase all content in the editing window. You’ll type your
                        XPath in the editing window and run it with the “Eval” button.</li>
                    <li>Learning XPath (and other languages, including XSLT, XQuery, Schematron)
                        means learning the …<ol>
                            <li>Vocabulary (e.g., the division operator in XPath is <code>div</code><a href="https://www.w3.org/TR/xpath-31/#id-arithmetic"><sup>⬀</sup></a>,
                                not <code>/</code>)</li>
                            <li>Syntax (e.g., in XPath <em>conditional expressions</em>,
                                the <code>if</code><a href="https://www.w3.org/TR/xpath-31/#doc-xpath31-IfExpr"><sup>⬀</sup></a> test must be parenthesized and an <code>else</code>
                                is required: <code>if (condition) then 1 else ()</code>)</li>
                            <li>Function library (e.g., <code>string-length()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-string-length"><sup>⬀</sup></a> and <code>count()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-count"><sup>⬀</sup></a> are functions, but there is no
                                    <code>length()</code> or <code>len()</code> or
                                    <code>size()</code>)</li>
                        </ol></li>
                    <li>All XPath expressions return a <em>sequence</em>. Sequences may
                        contain <em>nodes</em> (elements, attributes, etc.), <em>atomic
                        </em>values (strings, numbers, etc.), or both. A sequence of one item is
                        nonetheless a sequence, as is an <em>empty sequence</em>. Nested
                        sequences are automatically flattened.<ol>
                            <li>Type a number and hit Eval. This is a one-item sequence that
                                consists of a single atomic value. Try integers and decimal numbers.
                                Try wrapping the number in parentheses.</li>
                            <li>Type a string (inside single or double quotes) and hit Eval.
                                This is a one-item sequence that consists of a single atomic value.
                                Try omitting the quotation marks. Try using curly quotation marks.
                                Try wrapping the string in parentheses.</li>
                            <li>Type empty parentheses and hit Eval. This is an empty
                                sequence.</li>
                            <li>Type multiple items of different types (numbers, strings),
                                separated by commas. Try wrapping them in parentheses. Try wrapping
                                them in multiple parentheses. Try removing the commas. This is a
                                multi-item sequence.</li>
                            <li>Try to type a nested sequence, e.g., <code>(1, 2, (3,
                                    4))</code>, and hit Eval. What result do you expect? What do you
                                get?</li>
                        </ol></li>
                </ol></li><li>Simple XPath expressions (25 minutes; 10:30 a.m.–10:55 a.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li>Review: strings and numbers (atomic values) are XPath expressions <ol>
                            <li><code>"Hi, Mom!"</code> (Strings are enclosed in single or
                                double quotation marks—straight, not curly)</li>
                            <li><code>1</code> (Numbers are not enclosed in quotation
                                marks)</li>
                            <li><code>1.0</code> (What should this return? <em>lexical
                                    space</em> and <em>value space</em>)</li>
                        </ol></li>
                    <li>Arithmetic expressions are XPath expressions<ol>
                            <li><code>1 + 1</code></li>
                            <li>Practice: <code>+</code>, <code>-</code>, <code>*</code>,
                                    <code>div</code>, <code>idiv</code>, <code>mod</code>
                                    (<code>/</code> is not division)</li>
                        </ol></li>
                    <li>XPath library functions (with no arguments) are XPath expressions<ol>
                            <li><code>current-date()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-current-date"><sup>⬀</sup></a></li>
                            <li><code>current-time()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-current-time"><sup>⬀</sup></a></li>
                            <li><code>current-dateTime()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-current-dateTime"><sup>⬀</sup></a></li>
                        </ol></li>
                    <li>XPath library functions (with arguments) are XPath expressions<ol>
                            <li><code>upper-case('dhsi')</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-upper-case"><sup>⬀</sup></a> (How many arguments, and of what
                                type?)</li>
                            <li><code>concat('Curly', 'Larry', 'Moe')</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-concat"><sup>⬀</sup></a> (How many arguments, and
                                of what type?)</li>
                            <li><code>count(('Curly', 'Larry', 'Moe'))</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-count"><sup>⬀</sup></a> (Why two sets of
                                parentheses? Hint: How many arguments, and of what type?)</li>
                            <li>Function <em>signatures</em> and <em>cardinality</em>:
                                    <code>count($items as item()*) as xs:integer</code></li>
                        </ol>
                    </li>
                    <li>Nested XPath library functions and operations are XPath expressions. Read
                        them from the inside out<ol>
                            <li><code>max((1 + 2, 10 div 5, 6 * 0.2))</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-max"><sup>⬀</sup></a> (Remember those two sets
                                of parentheses?)</li>
                            <li><code>translate(upper-case('Hi, Mom!'),'AEIOU','xxxxx')</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-translate"><sup>⬀</sup></a> (How
                                is this different from <code>upper-case(translate('Hi,
                                    Mom!','AEIOU','xxxxx'))</code>?)</li>
                            <li><code>format-dateTime(current-dateTime(),'[h].[m01] [Pn] on [FNn],
                                    [D1o] [MNn]')</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-format-dateTime"><sup>⬀</sup></a></li>
                        </ol></li>
                    <li>Nested functions are hard to read. Use the <em>arrow
                            operator</em><a href="https://www.w3.org/TR/xpath-31/#id-arrow-operator"><sup>⬀</sup></a> (<code>=&gt;</code>) instead<ol>
                            <li><code>upper-case('Hi, Mom!') =&gt;
                                    translate('AEIOU','xxxxx')</code></li>
                            <li><code>current-dateTime() =&gt; format-dateTime('[h].[m01][Pn] on
                                    [FNn], [D1o] [MNn]')</code></li>
                        </ol></li>
                    <li>Path expressions may span multiple lines (try it with the examples above),
                        that is, new-line and space have the same meaning</li>
                </ol></li><li>XPath in &lt;oXygen/&gt; (20 minutes; 10:55 a.m.–11:15 a.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li>Launch &lt;oXygen/&gt; editor, hit <q>Ctrl+u</q> (Windows) or <q>Cmd+u</q>
                        (MacOS), copy and paste the string
                            <q>http://newtfire.org:8338/exist/apps/shakespeare/data/ham.xml</q>, and
                        hit <q>OK</q>. (Backup copy at
                            <q>https://raw.githubusercontent.com/ebeshero/UpTransformation/master/data/ham.xml</q>.)
                        This is a copy of <em>Hamlet</em> with TEI markup.</li>
                    <li>Set the dropdown in the upper left to <q>XPath 3.0</q>. (This widget is
                        called the <em>XPath Toolbar</em><a href="https://www.oxygenxml.com/doc/versions/20.0/ug-editor/topics/xpath-console.html"><sup>⬀</sup></a>.) Enter some XPath expressions (from above, such
                        as <code>1 + 1</code>). Limited to one line; hit <q>Enter</q> to run the
                        expression. The XPath Toolbar works only if you have an XML document open in
                        &lt;oXygen/&gt;, even if you aren’t using the document in your XPath
                        expression.</li>
                    <li>Go to Window → Show View → XPath/XQuery Builder. Set the dropdown in the
                        upper left to <q>XPath 3.0</q>. Enter some XPath expressions. May span
                        multiple lines; <q>Enter</q> for a new line. To run, hit <q>Ctrl+Enter</q>
                        (Windows) or <q>Cmd+Enter</q> (MacOS), or click the red right-pointed
                        triangle.</li>
                </ol></li><li>XPath path expressions (20 minutes; 11:15 a.m.–11:35 a.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li>An XPath <em>path expression</em> is a sequence of steps, each of
                        which proceeds from one node (called the <em>context node</em>) to a
                        sequence of zero (!) or more others. It returns the results in document
                        order (order of start tags). (Details at Kay 1227)</li>
                    <li>Sample XPath path expression: <code>/TEI/text/body/div</code>: start at
                        the document node, then navigate to a sequence of all its
                            <code>&lt;TEI&gt;</code> children. For each of those, navigate to all of
                        their <code>&lt;text&gt;</code> children, then to their
                            <code>&lt;body&gt;</code> children, and then to their
                            <code>&lt;div&gt;</code> children.</li>
                    <li>XPath steps are separated by single slashes (<code>/</code>).</li>
                    <li>An XPath expression that begins with a slash (<code>/</code>) starts at
                        the <em>document node</em>; this is an <em>absolute path</em>. Any
                        other XPath expression starts at the current context; this is a
                            <em>relative path</em>.</li>
                    <li>It is not an error to ask for something that doesn’t exist; it just
                        returns an empty sequence.</li>
                    <li>With <em>Hamlet</em> open and selected, go to the XPath Toolbar or
                        XPath Builder and try the following examples. Click on some of the results
                        in the lower panel:<ol>
                            <li><code>/TEI/teiHeader/fileDesc/titleStmt/title</code> (returns 1
                                    <code>&lt;title&gt;</code> element)</li>
                            <li><code>/TEI/text/body/div</code> (returns 5
                                    <code>&lt;div&gt;</code> elements)</li>
                            <li><code>/TEI/teiHeader/fileDesc/titleStmt/info</code> (returns no
                                results; this is not an error)</li>
                            <li><code>/TEI/teiHeader/fileDesc/title Stmt/title</code> (raises
                                an error; spaces are not allowed in path expressions)</li>
                        </ol></li>
                    <li>Namespaces matter in Real Life (XSLT, XQuery, Schematron), but the
                        &lt;oXygen/&gt; XPath Toolbar and XPath Builder take care of them for you
                        behind the scenes. eXide does not; you have to specify namespaces in
                        eXide.</li>
                </ol></li><li>XPath path steps (25 minutes; 11:35 a.m.–12:00 p.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li>Path steps move along axes: <code>child::</code>, <code>parent::</code>,
                            <code>descendant::</code>, <code>ancestor::</code>,
                            <code>preceding-sibling::</code>, <code>following-sibling::</code>, etc.
                        See:
                            <a href="http://dh.obdurodon.org/introduction-xpath.xhtml#xpath_axes">http://dh.obdurodon.org/introduction-xpath.xhtml#xpath_axes</a>.</li>
                    <li>Axes are specified with a double colon, e.g., <code>descendant::div</code>
                        matches all <code>&lt;div&gt;</code> descendants of the current context
                        node. There are two common shortcut notations<ol>
                            <li>The default is the <em>child</em> axis, so
                                    <code>/TEI/teiHeader</code> is synonymous with
                                    <code>/child::TEI/child::teiHeader</code>. Use the
                                shorthand.</li>
                            <li><code>//</code> is shorthand for
                                    <code>/descendant-or-self::</code>, so <code>/TEI//div</code>
                                finds all of the <code>&lt;div&gt;</code> elements that are
                                descendants of the <code>&lt;TEI&gt;</code> root element, that is,
                                anywhere in the document. The document node has a descendant axis,
                                too: <code>//div</code>. Be careful with this one!</li>
                        </ol>
                    </li>
                    <li>Each path step returns a sequence of zero or more context nodes for the
                        next path step. Only the final path step is permitted to return something
                        other than a node. Why?</li>
                    <li>The end of a path expression may return nodes or atomic values<ol>
                            <li><code>//body/div/count(descendant::sp)</code> navigates from
                                the document node to all of the acts in the play and then returns a
                                count of the speeches in each act</li>
                            <li>What’s wrong with <code>//body/div/count(//sp)</code>?
                                     <button class="answer">Answer</button> <span class="answer">The leading double slash resets the current context to
                                    the document node, and selects all <code>&lt;sp&gt;</code>
                                    elements in the entire document, instead of just the individual
                                    act.</span></li>
                        </ol></li>
                    <li><code>*</code> matches any element<ol>
                            <li><code>/TEI/teiHeader/*</code> matches all child elements of the
                                    <code>&lt;teiHeader&gt;</code></li>
                        </ol></li>
                    <li><code>..</code> matches the parent node of the current context node. That
                        is, it’s shorthand for <code>parent::*</code><ol>
                            <li><code>//stage/..</code> matches the parent nodes of all
                                    <code>&lt;stage&gt;</code> elements</li>
                        </ol></li>
                    <li>Find the acts (<code>&lt;div&gt;</code> children of
                            <code>&lt;body&gt;</code>) in <em>Hamlet</em>
                         <button class="answer">Answer</button> <span class="answer">
                            <code>//body/div</code>
                        </span></li>
                    <li>Find the stage directions (<code>&lt;stage&gt;</code>) in
                            <em>Hamlet</em>
                         <button class="answer">Answer</button> <span class="answer">
                            <code>//stage</code>
                        </span></li>
                    <li>Find the <code>&lt;stage&gt;</code> children of <code>&lt;div&gt;</code>
                        elements (but not other <code>&lt;stage&gt;</code> elements) in
                            <em>Hamlet</em>
                         <button class="answer">Answer</button> <span class="answer">
                            <code>//div/stage</code>
                        </span></li>
                    <li>Find the parents of the stage directions in <em>Hamlet</em>
                         <button class="answer">Answer</button> <span class="answer">
                            <code>//stage/..</code> or <code>//stage/parent::*</code>
                        </span></li>
                    <li>Find the <code>&lt;div&gt;</code> parents of the stage directions in
                            <em>Hamlet</em>, but not other parents  <button class="answer">Answer</button> <span class="answer">
                            <code>//stage/parent::div</code>
                        </span></li>
                </ol></li></ul></section>
        <section><h3>Exploring document structures and data with XPath (1:30 p.m.–4:00 p.m.)</h3><ul><li>XPath functions for strings (25 minutes; 1:30 p.m.–1:55 p.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li><code>concat()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-concat"><sup>⬀</sup></a>
                        <ol>
                            <li>
                                <code>concat('Curly','Larry','Moe')</code></li>
                            <li><code>concat('Curly is #', 1)</code></li>
                            <li>Or use the <em>concatenation operator</em><a href="https://www.w3.org/TR/xpath-31/#id-string-concat-expr"><sup>⬀</sup></a>: <code>'Curly is #' ||
                                1</code></li>
                            <li>What’s wrong with <code>concat(//speaker)</code>?  <button class="answer">Answer</button> <span class="answer">The
                                    arguments to <code>concat()</code> must be two or more
                                    individual atomic (or atomizable) items, and
                                        <code>//speaker</code> is a sequence.</span></li>
                        </ol>
                    </li>
                    <li><code>string-join()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-string-join"><sup>⬀</sup></a><ol>
                            <li><code>string-join(( 'Curly', 'Larry', 'Moe'), ',
                                ')</code></li>
                            <li><code>string-join(//speaker, ', ')</code></li>
                            <li><code>string-join(//speaker)</code> Why does this work when
                                    <code>concat(//speaker)</code> didn’t?  <button class="answer">Answer</button> <span class="answer">The first
                                    argument to <code>string-join()</code> is a sequence. All
                                    arguments to <code>concat()</code> must be atomic or
                                    atomizable.</span></li>
                        </ol></li>
                    <li><code>string-length()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-string-length"><sup>⬀</sup></a><ol>
                            <li><code>string-length('Curly, Larry, and Moe')</code></li>
                        </ol></li>
                    <li><code>lower-case()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-lower-case"><sup>⬀</sup></a>, <code>upper-case()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-upper-case"><sup>⬀</sup></a>
                        <ol>
                            <li><code>lower-case('Curly, Larry, and Moe')</code></li>
                        </ol></li>
                    <li><code>normalize-space()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-normalize-space"><sup>⬀</sup></a><ol>
                            <li><code>normalize-space(' Curly, Larry, Moe ')</code></li>
                        </ol></li>
                    <li><code>substring-before()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-substring-before"><sup>⬀</sup></a>, <code>substring-after()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-substring-after"><sup>⬀</sup></a><ol>
                            <li><code>substring-before('Larry', 'r')</code> What if there’s
                                more than one?</li>
                            <li><code>substring-after('Larry', 'r')</code> What if there’s more
                                than one?</li>
                        </ol></li>
                    <li><code>substring()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-substring"><sup>⬀</sup></a><ol>
                            <li><code>substring('Curly', 1, 2)</code> XPath starts counting
                                with 1 (not 0).</li>
                        </ol></li>
                    <li><code>contains()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-contains"><sup>⬀</sup></a> Foreshadowing: This returns a Boolean
                            (<code>True</code> or <code>False</code>) value. How might this be useful?<ol>
                            <li><code>contains('Ophelia', 'ph')</code></li>
                            <li><code>//speaker/contains(., 'ph')</code> (the dot refers to the
                                current context item)</li>
                        </ol></li>
                    <li><code>starts-with()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-starts-with"><sup>⬀</sup></a>, <code>ends-with()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-ends-with"><sup>⬀</sup></a><ol>
                            <li><code>starts-with('Ophelia', 'Op')</code></li>
                        </ol></li>
                </ol></li><li>XPath functions for numbers (20 minutes; 1:55 p.m.–2:15 p.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li><code>max()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-max"><sup>⬀</sup></a>, <code>min()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-min"><sup>⬀</sup></a>,
                            <code>sum()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-sum"><sup>⬀</sup></a>, <code>avg()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-avg"><sup>⬀</sup></a><ol>
                            <li><code>max((1, 2, 3))</code>, etc.</li>
                            <li>What happens when these are applied to strings? To a sequence
                                that mixes strings and numbers?</li>
                        </ol></li>
                    <li><code>ceiling()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-ceiling"><sup>⬀</sup></a>, <code>floor()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-floor"><sup>⬀</sup></a>
                        <ol>
                            <li><code>ceiling(3.141592653)</code></li>
                        </ol></li>
                    <li><code>round()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-round"><sup>⬀</sup></a><ol>
                            <li><code>round(3.141592653, 4)</code></li>
                        </ol></li>
                    <li><code>format-integer()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-format-integer"><sup>⬀</sup></a>, <code>format-number()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-format-number"><sup>⬀</sup></a><ol>
                            <li><code>format-integer(154,'w')</code></li>
                            <li><code>format-integer(154,'I')</code></li>
                            <li><code>format-number(1, '#.000')</code></li>
                            <li><code>format-number(1, '#.###')</code></li>
                        </ol></li>
                    <li>Find the length in character count of each <code>&lt;speaker&gt;</code>
                         <button class="answer">Answer</button> <span class="answer"><code>//speaker/string-length()</code> (why doesn’t
                                <code>string-length(//speaker)</code> work?)</span></li>
                    <li>Find the length of longest speaker name
                                 <button class="answer">Answer</button> <span class="answer"><code>max(//speaker/string-length())</code></span></li>
                </ol></li><li>XPath functions for sequences (15 minutes; 2:15 p.m.–2:30 p.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li><code>distinct-values()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-distinct-values"><sup>⬀</sup></a>
                        <ol>
                            <li><code>distinct-values(/TEI//speaker)</code></li>
                        </ol></li>
                    <li><code>count()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-count"><sup>⬀</sup></a><ol>
                            <li><code>count(('Curly', 'Larry', 'Moe',
                                'Curly'))</code></li>
                            <li><code>count(distinct-values(('Curly', 'Larry', 'Moe',
                                    'Curly')))</code></li>
                            <li><code>distinct-values(count(('Curly', 'Larry', 'Moe',
                                    'Curly')))</code></li>
                        </ol></li>
                    <li><code>sort()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-sort"><sup>⬀</sup></a><ol>
                            <li><code>sort(//speaker)</code></li>
                            <li><code>sort(//speaker,(), function($item)
                                    {string-length($item)})</code></li>
                        </ol></li>
                    <li>How many <code>&lt;speaker&gt;</code> elements are there in
                            <em>Hamlet</em>?
                         <button class="answer">Answer</button> <span class="answer"><code>count(//speaker)</code></span></li>
                    <li>How many <em>distinct</em>
                        <code>&lt;speaker&gt;</code> elements are there in <em>Hamlet</em>?
                                 <button class="answer">Answer</button> <span class="answer"><code>count(distinct-values(//speaker))</code></span></li>
                    <li>How many acts are there in <em>Hamlet</em>?
                                 <button class="answer">Answer</button> <span class="answer"><code>count(//body/div)</code></span></li>
                    <li>How many scenes are there in <em>Hamlet</em>?
                                 <button class="answer">Answer</button> <span class="answer"><code>count(//div/div)</code></span></li>
                    <li>What does <code>count(//div)</code> tell you about <em>Hamlet</em>,
                        and why is it unhelpful?  <button class="answer">Answer</button> <span class="answer">It counts <code>&lt;div&gt;</code> elements
                            of different types together: acts, scenes, cast list.</span></li>
                </ol></li><li>Looking Stuff Up: XPath function signatures and cardinality (10 minutes; 2:30 p.m.–2:40 p.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li>The <em>function signature</em> is the number and type of arguments it
                        accepts or requires</li>
                    <li><em>Type error</em>: <code>string-length(1.2345)</code></li>
                    <li><em>Cardinality error</em>:
                        <code>string-length(/TEI/speaker)</code></li>
                    <li>Why is <code>count(/TEI//speaker)</code> okay, while <code>count('Curly',
                            'Larry', 'Moe')</code> is broken?</li>
                    <li>The error message is your friend. Read it.</li>
                    <li>Resources and references:
                            <a href="https://ebeshero.github.io/UpTransformation/References.html">https://ebeshero.github.io/UpTransformation/References.html</a></li>
                    
                </ol></li><li>Break (10 minutes; 2:40 p.m.–2:50 p.m.) </li><li>XPath predicates (20 minutes; 2:50 p.m.–3:10 p.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li><em>Predicates</em>, in square brackets after a path step,
                            <em>filter</em> the results</li>
                    <li>Numerical predicates<ol>
                            <li><code>//body/div[3]</code> matches the third
                                    <code>&lt;div&gt;</code> child of each <code>&lt;body&gt;</code>
                                element (same as <code>//body/div[position() eq 3]</code></li>
                            <li><code>//body/div[last()]</code> matches the last
                                    <code>&lt;div&gt;</code> child of each <code>&lt;body&gt;</code>
                                element (same as <code>//body/div[position() eq 3]</code></li>
                            <li>Numerical predicates count away from the context node<ol>
                                    
                                    <li><code>//sp/ancestor[1]</code> is equivalent to
                                            <code>//sp/..</code></li>
                                </ol></li>
                        </ol></li>
                    <li>Predicates with node tests<ol>
                            <li><code>//stage[parent::div]</code> is equivalent to
                                    <code>//div/stage</code></li>
                        </ol></li>
                    <li>Predicates with operators and functions<ol>
                            <li><code>//sp[speaker eq 'Ophelia']</code></li>
                            <li><code>//sp[contains(speaker, 'Rosencrantz')]</code></li>
                            <li><code>//lg[@type eq 'couplet']</code></li>
                        </ol></li>
                </ol></li><li>Odds and ends (15 minutes; 3:10 p.m.–3:25 p.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li>Three ways to apply a function to a sequence<ol>
                            <li>Explicit <code>for</code><ol>
                                    <li><code>for $speaker in /TEI//speaker return
                                            contains($speaker, 'ph')</code></li>
                                </ol></li>
                            <li>Implicit <code>for</code><ol>
                                    <li><code>/TEI//speaker/contains(., 'ph')</code></li>
                                </ol></li>
                            <li>Simple map (<code>!</code><a href="https://www.w3.org/TR/xpath-31/#id-map-operator"><sup>⬀</sup></a>)<ol>
                                    <li><code>/TEI//speaker ! contains(.,
                                        'ph')</code></li>
                                </ol></li>
                        </ol></li>
                    <li>Difference between simple map (<code>!</code><a href="https://www.w3.org/TR/xpath-31/#id-map-operator"><sup>⬀</sup></a>) and
                        arrow (<code>=&gt;</code><a href="https://www.w3.org/TR/xpath-31/#id-arrow-operator"><sup>⬀</sup></a>) <ol>
                            <li><code>('Curly', 'Larry', 'Moe') =&gt; count()</code></li>
                            <li><code>('Curly', 'Larry', 'Moe') ! count(.)</code></li>
                        </ol></li>
                    
                </ol></li><li>Read and evaluate XML projects with XPath (35 minutes; 3:25 p.m.–4:00 p.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li>How many speeches (<code>&lt;sp&gt;</code>) does Ophelia have?
                                 <button class="answer">Answer</button> <span class="answer"><code>count(//sp[speaker eq
                        'Ophelia'])</code></span></li>
                    <li>How many speeches does Ophelia have in Act 2?
                                 <button class="answer">Answer</button> <span class="answer"><code>count(//body/div[2]//sp[speaker eq
                            'Ophelia'])</code></span></li>
                    <li>What types of elements can have stage directions
                            (<code>&lt;stage&gt;</code>) as children? (Hint: use the <code>name()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-name"><sup>⬀</sup></a>
                        function.)
                         <button class="answer">Answer</button> <span class="answer"><code>distinct-values(//stage/../name())</code></span></li>
                    <li>How many speeches don’t contain any metrical lines
                        (<code>&lt;l&gt;</code>)?
                         <button class="answer">Answer</button> <span class="answer"><code>count(//sp[not(l)])</code></span></li>
                    <li>Building on your answer to the last question, who are the speakers of
                        those speeches?
                             <button class="answer">Answer</button> <span class="answer"><code>distinct-values(//sp[not(l)]/speaker)</code></span></li>
                    <li>Building on your answer to the last two questions, what kinds of elements
                        they contain instead?
                                 <button class="answer">Answer</button> <span class="answer"><code>distinct-values(//sp[not(l)]/*/name())</code></span></li>
                    <li>What is Hamlet’s first speech?  <button class="answer">Answer</button> <span class="answer"><code>(//sp[speaker eq
                                'Hamlet']/l)[1]</code></span></li>
                    <li>What is the last stage direction in the entire document?
                                 <button class="answer">Answer</button> <span class="answer"><code>(//stage)[last()]</code></span></li>
                    <li>How many speeches have more than 8 line children?
                                 <button class="answer">Answer</button> <span class="answer"><code>count(//sp[count(l) gt 8])</code></span></li>
                    <li>Building on your answer to the preceding question, how many line children
                        does each of those speeches have?  <button class="answer">Answer</button> <span class="answer"><code>//sp[count(l) gt
                                8]/count(l)</code></span></li>
                    <li>Building on your answers to the preceding two questions, who are the
                        speakers of speeches that have more than 8 line children?
                                 <button class="answer">Answer</button> <span class="answer"><code>distinct-values(//sp[count(l) gt
                            8]/speaker)</code></span></li>
                    <li>How long is the longest speech?
                                 <button class="answer">Answer</button> <span class="answer"><code>max(//sp/string-length())</code> (or, better:
                                <code>max(//sp/string-length(normalize-space()))</code>)</span></li>
                    <li>Building on your answer to the last question, who is the speaker of the
                        longest speech?  <button class="answer">Answer</button> <span class="answer"><code>//sp[string-length() eq
                                max(//sp/string-length())]/speaker</code> (or, better:
                                <code>//sp[string-length(normalize-space()) eq
                                max(//sp/string-length(normalize-space()))]/speaker</code>)</span></li>
                </ol></li></ul></section>
    </section>
    <section>
        <h2>Tuesday, June 12: XPath and XQuery</h2>
        <section><h3>XPath and XQuery in eXist-db (9:00 a.m.–12:00 p.m.)</h3><ul><li>Housekeeping: documents, collections, and namespaces (10 minutes; 9:00 a.m.–9:10 a.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li>In the eXide window, click on the <q>New XQuery</q> tab. This brings up a
                        window with <code>xquery version "3.1";</code> at the top.</li>
                    <li>Access a document with the XPath <code>doc()</code> function<ol>
                            <li><code>doc('/db/apps/shakespeare/data/ham.xml')</code></li>
                        </ol>
                    </li>
                    <li>Access a collection of documents with the XPath <code>collection()</code> function<ol>
                            <li><code>collection('/db/apps/shakespeare/data/')</code></li>
                        </ol>
                    </li>
                    <li>When working with XML in a namespace (like the TEI), declare the
                        namespace, bind it to a prefix, and use the prefix<ol>
                            <li><code>declare namespace
                                    tei="http://www.tei-c.org/ns/1.0";</code> (<code>declare</code>
                                statements require a final semicolon)</li>
                            <li><code>&lt;stage&gt;</code> elements in <em>Hamlet</em>:
                                    <code>doc('/db/apps/shakespeare/data/ham.xml')//tei:stage</code></li>
                            <li>Find all the stage directions in the entire Shakespeare
                                collection?
                                         <button class="answer">Answer</button> <span class="answer"><code>collection('/db/apps/shakespeare/data/')//tei:stage</code></span>
                            </li>
                        </ol></li>
                </ol></li><li>The seven types of nodes (30 minutes; 9:10 a.m.–9:40 a.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li><code>document()</code></li>
                    <li><code>element()</code></li>
                    <li><code>attribute()</code><ol>
                            <li><code>doc('/db/apps/shakespeare/data/')//tei:sp/@who</code></li>
                            <li><code>doc('/db/apps/shakespeare/data/')//tei:sp/@who/string()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-string"><sup>⬀</sup></a></li>
                        </ol>
                    </li>
                    <li><code>text()</code> (not a function; not to be confused with
                            <code>string()</code>)<ol>
                            <li><code>doc('/db/mitford/literary/Charles1.xml')//tei:stage</code>
                                (Mary Russell Mitford’s <em>Charles the First</em> tragedy) </li>
                            <li>What does
                                    <code>doc('/db/mitford/literary/Charles1.xml')//tei:stage/string()</code>
                                return?  <button class="answer">Answer</button> <span class="answer">The string values of the stage directions, that is,
                                    the stage directions with all markup stripped</span></li>
                            <li>What does
                                    <code>doc('/db/mitford/literary/Charles1.xml')//tei:stage/text()</code>
                                return?  <button class="answer">Answer</button> <span class="answer">The <code>text()</code> nodes in each stage
                                    direction</span></li>
                        </ol>
                    </li>
                    <li>Rarely used: <code>comment()</code>, <code>namespace()</code>,
                            <code>processing-instruction()</code></li>
                </ol></li><li>Neglected XPath axes (25 minutes; 9:40 a.m.–10:05 a.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li><code>preceding::</code>, <code>following::</code><ol>
                            <li>Find all the stage directions (<code>&lt;stage&gt;</code>) that
                                precede Act 2, Scene 2 in <em>Charles the First</em>
                                 <button class="answer">Answer</button> <span class="answer"><code>doc('/db/mitford/literary/Charles1.xml')//tei:body/tei:div[2]/tei:div[2]/preceding::tei:stage</code></span>
                            </li>
                        </ol></li>
                    <li><code>self::</code><ol>
                            <li><code>doc('/db/mitford/literary/Charles1.xml')//tei:body/tei:div/tei:div/tei:head/following-sibling::*[2]</code></li>
                            <li><code>doc('/db/mitford/literary/Charles1.xml')//tei:body/tei:div/tei:div/tei:head/following-sibling::*[2][self::tei:stage]</code></li>
                            <li><code>doc('/db/mitford/literary/Charles1.xml')//tei:body/tei:div/tei:div/tei:head/following-sibling::*[2][not(self::tei:stage)]</code></li>
                            <li><code>doc('/db/mitford/literary/Charles1.xml')//tei:speaker[.
                                    eq 'Queen.']</code></li>
                            <li><code>doc('/db/mitford/literary/Charles1.xml')//tei:speaker[self::node()
                                    eq 'Queen.']</code></li>
                        </ol></li>
                    <li><code>ancestor::</code>, <code>ancestor-or-self::</code>,
                            <code>descendant-or-self::</code>, <code>namespace::</code><ol>
                            <li><code>//speaker[. eq 'Queen.']/ancestor::div[@type eq
                                    'act']/@n</code></li>
                        </ol></li>
                </ol></li><li> Scavenger hunt 1 (40 minutes; 10:05 a.m.–10:45 a.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li>Work with the Digital Mitford Site Index posted in eXist at
                            <a href="/db/mitford/si.xml">/db/mitford/si.xml</a> or the official version at its external
                        location: <a href="http://digitalmitford.org/si.xml">http://digitalmitford.org/si.xml</a> Can you find out the
                        following? <ol>
                            <li> Look at the <code>div</code> elements in the site index. What
                                attribute on this element can tell you how the document is
                                organized? Write an XPath that isolates these attribute values.
                                     <button class="answer">Answer</button> <span class="answer">doc('http://digitalmitford.org/si.xml')//tei:div/@type/string()</span></li>
                            <li>Look element children of the <code>&lt;div&gt;</code> elements
                                (you can do this without seeing what all the elements are). What
                                attribute on these elements can be used to differentiate the various
                                lists in the document? Complete this XPath by isolating these
                                attribute values.
                                         <button class="answer">Answer</button> <span class="answer"><code>doc('http://digitalmitford.org/si.xml')//tei:div/*/@sortKey</code>
                                    or
                                        <code>doc('http://digitalmitford.org/si.xml')//tei:div/*/@*</code></span>
                            </li>
                            <li>Without knowing the names of the elements that are members of
                                lists, you can tell that all follow the same XPath pattern. What is
                                it?
                                         <button class="answer">Answer</button> <span class="answer"><code>doc('http://digitalmitford.org/si.xml')//tei:div/*/*
                                        or </code> or
                                        <code>doc('http://digitalmitford.org/si.xml')//tei:div/*/*[@xml:id]</code></span></li>
                            <li>The <code>@xml:id</code> for the play <em>Charles the
                                    First</em> in the site index is "CharlesI_MRMplay". References
                                to the play throughout the site index will be made with various
                                attributes that begin with a hashtag, formatted like this:
                                "#CharlesI_MRMplay". Knowing this, can you locate all the individual
                                entries in the site index lists that contain references of any kind
                                to the play?
                                         <button class="answer">Answer</button> <span class="answer"><code>doc('http://digitalmitford.org/si.xml')//tei:div/*/*[@xml:id][descendant::*/@*="#CharlesI_MRMplay"]</code>
                                    How can you find out how many these are using a function?
                                        <code>doc('http://digitalmitford.org/si.xml')//tei:div/*/*[@xml:id][descendant::*/@*="#CharlesI_MRMplay"]
                                        =&gt; count()</code>
                                </span>
                            </li>
                        </ol>
                    </li>
                </ol></li><li>Break (10 minutes; 10:45 a.m.–10:55 a.m.) </li><li>Regex in XPath (35 minutes; 10:55 a.m.–11:30 a.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li><code>contains()</code> vs. <code>matches()</code><ol>
                            <li>
                                <code>doc('/db/mitford/literary/Charles1.xml')//tei:l[contains(.,
                                    'murder')]</code>
                            </li>
                            <li><code>doc('/db/mitford/literary/Charles1.xml')//tei:l[contains(.,
                                    'unrighteousness')]</code></li>
                            <li><code>doc('/db/mitford/literary/Charles1.xml')//tei:l[matches(.,
                                    '[a-z]{15,}','i')]</code></li>
                            <li>
                                <code>doc('/db/mitford/literary/Charles1.xml')//tei:*/text()[matches(.,
                                    '\d{4}')]</code>
                            </li>
                            <li><code>doc('/db/mitford/literary/Charles1.xml')//tei:*/text()[matches(.,
                                    '(^|\D)\d{4}(^|\D)')]</code> Why is the number of results
                                smaller than for the previous expression?</li>
                        </ol></li>
                    <li><code>translate()</code> vs. <code>replace()</code>
                        <ol>
                            <li>Try this expression,
                                doc('/db/mitford/literary/Charles1.xml')//tei:castList, and notice
                                the pseudomarkup in the cast list. <code>translate()</code> to the
                                rescue!
                                    <code>doc('/db/mitford/literary/Charles1.xml')//tei:castList//tei:roleDesc/translate(.,
                                    '()', '')</code></li>

                            <li>The next examples work with the <code>@xml:id</code>s on the
                                    <code>tei:l</code> elements. How can you get a look at the
                                    <code>@xml:id</code>s first?
                                         <button class="answer">Answer</button> <span class="answer"><code>doc('/db/mitford/literary/Charles1.xml')//tei:l/@xml:id/string()</code></span></li>
                            <li>Change the format of the line <code>@xml:id</code>s with
                                    <code>replace()</code>:
                                    <code>doc('/db/mitford/literary/Charles1.xml')//tei:l/replace(@xml:id,
                                    'Chas(_\w+_)', 'C1$1')</code></li>
                        </ol>
                    </li>
                    <li><code>substring-before()</code> and <code>substring-after()</code> vs.
                            <code>tokenize()</code>
                        <ol>
                            <li>Return only location (e.g. ded, pro, act) and line number
                                information in the <code>@xml:id</code>s:
                                    <code>doc('/db/mitford/literary/Charles1.xml')//tei:l/substring-after(@xml:id,
                                    'Chas_')</code>
                            </li>
                            <li>Working with the expression we just wrote, how would you apply
                                    <code>substring-before()</code> to return only the location
                                (ded, pro, act), and trim off the line number information?
                                     <button class="answer">Answer</button> <span class="answer">Two ways: old-fashioned:
                                        <code>doc('/db/mitford/literary/Charles1.xml')//tei:l/substring-before(substring-after(@xml:id,
                                        'Chas_'), '_')</code> and more legible with simple map
                                    operator:
                                        <code>doc('/db/mitford/literary/Charles1.xml')//tei:l/substring-after(@xml:id,
                                        'Chas_') ! substring-before(.,'_')</code> Why can’t we use
                                    the arrow operator (<code>=&gt;</code>) here?</span>
                            </li>
                        </ol></li>
                </ol></li><li>Introducing variables (30 minutes; 11:30 a.m.–12:00 p.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li>Global variables and syntax, how to return their values in eXist-db</li>
                    <li><code>FLWOR</code> variables: <code>for</code>, <code>let</code>,
                            <code>where</code>, <code>order by</code>, <code>return</code></li>
                    <li>The simplest <code>FLWOR</code>: <code>let</code> and <code>return</code>
                        <ol>
                            <li>Retrieve whole elements</li>
                            <li>Retrieve only their text</li>
                        </ol>
                    </li>
                </ol></li></ul></section>
        <section><h3>XQuery flow control (1:30 p.m.–4:00 p.m.)</h3><ul><li>Defining variables: XPath expressions with functions and predicates (30 minutes; 1:30 p.m.–2:00 p.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li><code>FLWOR</code> Scavenger hunt 2: [Write FLWOR statements
                        mimicking/extending the previous Scavenger Hunt.]</li>
                </ol></li><li>XPath <code>for</code> loops; sequence and range variables
                    (&lt;oXygen/&gt;) (30 minutes; 2:00 p.m.–2:30 p.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li><code>for $i in (sequence) return ...</code></li>
                    <li>Practice examples in &lt;oXygen/&gt; <ol>
                            <li>Use XPath builder window: for each of a set of attributes,
                                return something associated with each one.</li>
                        </ol>
                    </li>

                </ol></li><li>Break (10 minutes; 2:30 p.m.–2:40 p.m.) </li><li><code>FLWOR</code> statements: how <code>for</code> works (40 minutes; 2:40 p.m.–3:20 p.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li><code>for $i in $YourSequenceVariable</code> and iterative returns</li>
                    <li>The <code>$pos</code> variable: <code>for $i at $pos in
                            $YourSequenceVariable</code></li>
                    <li>Sorting and ordering: XPath <code>sort()</code> function: using this above
                        a for-loop, vs. the XQuery <code>order by</code> statement inside a for-loop
                        to control the order of processing and returns.</li>
                    <li>Adding <code>where</code> in a <code>for-loop</code> to limit the
                        returns</li>
                    <li>Which is more efficient in XQuery: a predicate or <code>where</code>?
                    </li>
                </ol></li><li><img src="images/flower.jpg" alt="'To create a little flower is the labour of ages.' –William Blake, The Proverbs of Hell" title="'To create a little flower is the labour of ages.' –William Blake, The Proverbs of Hell" class="icon"/>Putting it all together: FLWOR for pulling data (40 minutes; 3:20 p.m.–4:00 p.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li>Text returns: combining strings into one result: <code>concat()</code> and
                            <code>string-join()</code></li>

                    <li>HTML returns: how to use curly braces to layer and activate XQuery in an
                        HTML file.</li>
                </ol></li></ul></section>
    </section>
    <section>
        <h2>Wednesday, June 13: XPath and XSLT</h2>
        <section><h3>Introduction to XPath in XSLT (9:00 a.m.–12:00 p.m.)</h3><ul><li>XSLT overview (40 minutes; 9:00 a.m.–9:40 a.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li>XSLT (eXtensible Stylesheet Language Transformations) is an XML document
                        with special namespaced elements designed to process XML documents</li>
                    <li>Basic structure: <code>&lt;xsl:stylesheet&gt;</code> is the root element,
                        with <code>&lt;xsl:template&gt;</code> children.</li>
                    <li>A <em>declarative programming language</em>. Not written to be
                        executed in a line-by-line order. Template elements (or <em>template
                            rules</em>) do the work, but can be written in any order. </li>
                    <li>Templates match patterns: <code>&lt;xsl:template match="???"&gt;</code>:
                        The <code>@match</code> here is a special kind of XPath called an
                            <em>XPath pattern</em>, which could be found anywhere in the
                        document hierarchy. Note: It is inefficient for processing to write these
                        pattern expressions as we would an XPath search in the XPath Toolbar.</li>
                    <li>In each example below, look at the <code>@match</code> value: What should
                        the XPath pattern be matching in the source XML document? And how is this
                        XPath different from the way we write XPath in the XPath Toolbar? <ol>
                            <li><code>&lt;xsl:template match="div/head&gt;"</code>
                                 <button class="answer">Answer</button> <span class="answer">Matches any <code>&lt;head&gt;</code> child of a
                                        <code>&lt;div&gt;</code> at any level of the XML hierarchy.
                                    In the XPath Toolbar, we have to start the expression with two
                                    leading forward slashes (<code>//</code>) to indicate we are
                                    looking <q>down</q> the tree from the document node.</span>
                            </li>
                            <li><code>&lt;xsl:template match="div[count(descendant::p) gt
                                    1]&gt;"</code>
                                 <button class="answer">Answer</button> <span class="answer">Matches any <code>&lt;div&gt;</code> element that contains
                                    multiple (more than one) <code>&lt;p&gt;</code> descendants. In
                                    the XPath toolbar, we must add <code>//</code> to the
                                    beginning.</span>
                            </li>
                        </ol>
                    </li>
                    <li>Inside template rules, <code>&lt;xsl:apply-templates&gt;</code> drives the
                        selection of the next template rules to fire.
                            <code>&lt;xsl:apply-templates&gt;</code>
                        <em>consumes</em> the XML node matched in the template rule, and
                        determines that its children or other nodes in a set XPath relationship to
                        the template match will be processed. </li>
                    <li><code>xsl:apply-templates</code> with or without an <code>@select</code>:
                            <code>@select</code>
                        <q>prunes the tree</q> with a specific XPath expression that specifically
                        identifies which XML elements in the source document will be processed next.
                        Without <code>@select</code>, all element contents are consumed and
                        processed by default.</li>
                    <li>The XPath expression in <code>@select</code> is <em>literal</em> and
                        defined by its relation to the node being matched by the template rule (in
                        the <code>@match</code> on <code>xsl:template</code>. </li>
                    <li><code>xsl:apply-templates</code> with or without <code>@select</code>:
                            <code>@select</code>
                        <q>prunes the tree</q> with an XPath expression that specifically identifies
                        which XML elements in the source document will be processed next. Without
                            <code>@select</code>, all element contents are consumed and processed by
                        default.</li>
                    <li>The XPath expression in <code>@select</code> is <em>literal</em> and
                        defined by its relation to the node being matched by the template rule (in
                        the <code>@match</code> on <code>xsl:template</code>. </li>
                </ol></li><li>Preparing to write XSLT in &lt;oXygen/&gt; (45 minutes; 9:40 a.m.–10:25 a.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li>Namespaces and where they matter: <q>It’s always a namespace issue.</q>
                        <ol>
                            <li><code>xsl:</code>: distinguishes the XSLT elements</li>
                            <li>Namespaced input: set <code>xpath-default-namespace</code> on
                                the xsl:stylesheet:
                                    <code>xpath-default-namespace="http://www.tei-c.org/ns/1.0"</code>
                            </li>
                            <li>Namespaced output: set
                                    <code>xmlns="http://www.w3.org/1999/xhtml"</code>
                            </li>
                        </ol>
                    </li>
                    <li><code>xsl:output</code> attributes: <code>@method</code>,
                            <code>@indent</code>, <code>@omit-xml-declaration</code>,
                            <code>@doctype-system</code>
                        <ol>
                            <li><code>&lt;xsl:output method="xml" indent="no"
                                    omit-xml-declaration="yes"/&gt;</code></li>
                            <li><code>&lt;xsl:output method="xhtml" encoding="utf-8"
                                    indent="yes" doctype-system="about:legacy-compat"
                                    omit-xml-declaration="yes"/&gt;</code></li>
                        </ol>
                    </li>
                </ol></li><li>Break (10 minutes; 10:25 a.m.–10:35 a.m.) </li><li>Identity transformation: making a change to an XML file (40 minutes; 10:35 a.m.–11:15 a.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li>Repair our Pacific Voyage file:
                            <a href="http://dh.newtfire.org/XSLTExercise1.html">http://dh.newtfire.org/XSLTExercise1.html</a></li>
                </ol></li><li>Preparing to output HTML from XML (45 minutes; 11:15 a.m.–12:00 p.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li>Housekeeping: <code>&lt;xsl:stylesheet&gt;</code> and
                            <code>&lt;xsl:output&gt;</code></li>
                    <li>Template matching on the document node to output HTML</li>
                    <li> Structure of an HTML document: <code>&lt;head&gt;</code> and
                            <code>&lt;body&gt;</code></li>
                </ol></li></ul></section>
        <section><h3>XSLT: XML to HTML transformation (1:30 p.m.–4:00 p.m.)</h3><ul><li><code>&lt;xsl:apply-templates&gt;</code> and the <code>@select</code>
                    attribute (45 minutes; 1:30 p.m.–2:15 p.m.) </li><li>XSLT push and pull processing (25 minutes; 2:15 p.m.–2:40 p.m.) </li><li>Break (10 minutes; 2:40 p.m.–2:50 p.m.) </li><li>When to use <code>&lt;xsl:value-of&gt;</code> (35 minutes; 2:50 p.m.–3:25 p.m.) </li><li>Comparing XSLT and XQuery (35 minutes; 3:25 p.m.–4:00 p.m.) </li></ul></section>
    </section>
    <section>
        <h2>Thursday, June 14: XPath and Schematron</h2>
        <section><h3>Using Schematron to constrain your markup (9:00 a.m.–12:00 p.m.)</h3><ul><li>Schematron overview (15 minutes; 9:00 a.m.–9:15 a.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li>Schematron is <em>constraint based</em>; Relax NG, XML Schema, DTD are
                            <em>grammar based</em></li>
                    <li>Sample constraint-based tasks involve multiple elements<ol>
                            <li>Are start pages (<code>&lt;start&gt;</code>) no larger than end
                                pages (<code>&lt;end&gt;</code>)?</li>
                            <li>Are birth dates no later than death dates?</li>
                            <li>Does a list (e.g., of students in a course) contain
                                duplicates?</li>
                            <li>Do pointers to persons really point to persons (and not
                                places)?</li>
                        </ol></li>
                    <li>Schematron structure: <code>&lt;pattern&gt;</code> →
                            <code>&lt;rule&gt;</code> → <code>&lt;assert&gt;</code> or
                            <code>&lt;report&gt;</code></li>
                </ol></li><li>Looking at Schematron (30 minutes; 9:15 a.m.–9:45 a.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li>Open each of the following URLs in &lt;oXygen/&gt; (select, copy, Ctrl+u
                        (Windows) or Cmd+u (MacOS)<ol>
                            <li>Document analysis of our XML: https://raw.githubusercontent.com/ebeshero/UpTransformation/master/data/pages.xml<ol>
                                    <li><code>&lt;start&gt;</code> shouldn’t be greater than
                                            <code>&lt;end&gt;</code></li>
                                    <li><code>&lt;issue&gt;</code> is optional, but we could
                                        omit it by mistake</li>
                                    <li><code>&lt;initial&gt;</code> should usually be one
                                        letter</li>
                                    <li>Apostrophes and quotation marks should usually be curly
                                        (“, ”, ‘, ’), not straight (', ")</li>
                                </ol></li>
                            <li>What Relax NG can constrain: https://raw.githubusercontent.com/ebeshero/UpTransformation/master/data/pages.rnc<ol>
                                    <li><code>&lt;volume&gt;</code>,
                                        <code>&lt;issue&gt;</code>, <code>&lt;year&gt;</code>,
                                            <code>&lt;start&gt;</code>, and <code>&lt;end&gt;</code>
                                        must be positive integers</li>
                                    <li><code>&lt;year&gt;</code> must be exactly four
                                        digits</li>
                                    <li><code>&lt;issue&gt;</code> is optional</li>
                                </ol></li>
                            <li>Schematron to the rescue: https://raw.githubusercontent.com/ebeshero/UpTransformation/master/data/pages.sch<ol>
                                    <li>Anatomy of a schematron rule</li>
                                    <li>Validating start and end pages</li>
                                    <li>Validating apostrophes and quotation marks</li>
                                </ol></li>
                        </ol></li>
                    <li>Associating Schematron with XML</li>
                </ol></li><li>Schematron error reporting (20 minutes; 9:45 a.m.–10:05 a.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li>Schematron has the best error messages</li>
                    <li>Enhance Schematron reporting with <code>&lt;sch:value-of&gt;</code>:
                        https://raw.githubusercontent.com/ebeshero/UpTransformation/master/data/pages_value-of.sch</li>
                    <li>Enhance Schematron maintenance with <code>&lt;sch:let&gt;</code>:
                        https://raw.githubusercontent.com/ebeshero/UpTransformation/master/data/pages_variables.sch</li>
                    <li>Generate warnings as well as errors:
                        https://raw.githubusercontent.com/ebeshero/UpTransformation/master/data/pages_warnings.sch</li>
                </ol></li><li>XPath functions practice: Leipzig glossing rules, part 1 (20 minutes; 10:05 a.m.–10:25 a.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li>Target output:
                            <a href="http://htmlpreview.github.io/?https://github.com/ebeshero/UpTransformation/blob/master/data/leipzig.html">http://htmlpreview.github.io/?https://github.com/ebeshero/UpTransformation/blob/master/data/leipzig.html</a></li>
                    <li>Document analysis of our XML:
                        https://raw.githubusercontent.com/ebeshero/UpTransformation/master/data/leipzig.xml</li>
                    <li>Best practice<ol>
                            <li>Incremental development and testing</li>
                            <li>Testing separately</li>
                        </ol></li>
                    <li>Schematron validation<ol>
                            <li>Housekeeping: create the Schematron skeleton in
                                &lt;oXygen/&gt;, save it, link it to XML</li>
                            <li>Two ways of counting spaces and hyphens<ol>
                                    <li><code>translate()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-translate"><sup>⬀</sup></a> <button class="answer">Answer</button> <span class="answer"><code>string-length('one two
                                                three') - string-length(translate('one two three', '
                                                ', ''))</code></span></li>
                                    <li><code>tokenize()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-tokenize"><sup>⬀</sup></a>
                                         <button class="answer">Answer</button> <span class="answer"><code>count(tokenize('one two three', '
                                            '))</code></span></li>
                                </ol></li>
                        </ol></li>
                </ol></li><li>Break (10 minutes; 10:25 a.m.–10:35 a.m.) </li><li>XPath functions practice: Leipzig glossing rules, part 2 (25 minutes; 10:35 a.m.–11:00 a.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li>One more way of counting spaces and hyphens<ol>
                            <li>1) Explode the string, 2) find the index values of the space
                                characters, and 3) count them</li>
                            <li>Explode the string: <code>string-to-codepoints()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-string-to-codepoints"><sup>⬀</sup></a>, <code>codepoints-to-string()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-codepoints-to-string"><sup>⬀</sup></a><ol>
                                    <li><code>for $c in string-to-codepoints('one two three')
                                            return codepoints-to-string($c)</code></li>
                                </ol></li>
                            <li>Find the index values of the spaces: <code>index-of()</code><a href="https://www.w3.org/TR/xpath-functions-31/#func-index-of"><sup>⬀</sup></a><ol>
                                    <li><code>index-of(('a', 'b', 'c', 'b', 'a'),
                                        'a')</code></li>
                                </ol></li>
                            <li>Count them: <code>count(index-of(for $c in
                                    string-to-codepoints('one two three') return
                                    codepoints-to-string($c), ' '))</code></li>
                            <li>Make it legible: <code>string-to-codepoints('one two three') !
                                    codepoints-to-string(.) =&gt; index-of(' ') =&gt;
                                count()</code></li>
                        </ol>
                    </li>
                    <li>Comparing three things</li>
                    <li>Whitespace normalization<ol>
                            <li>Require it in the XML? (Relax NG, Schematron)</li>
                            <li>Manage it inside tier-comparison</li>
                            <li>Schematron</li>
                        </ol>
                    </li>
                </ol></li><li>Grouping; looping over distinct values, mapping back to the tree (60 minutes; 11:00 a.m.–12:00 p.m.) </li></ul></section>
        <section><h3>Writing Schematron with XPath function (1:30 p.m.–4:00 p.m.)</h3><ul><li>Lab session (sample materials provided, or work with your own data), part
                    1 (70 minutes; 1:30 p.m.–2:40 p.m.) </li><li>Break (10 minutes; 2:40 p.m.–2:50 p.m.) </li><li>Lab session (sample materials provided, or work with your own data), part
                    2 (70 minutes; 2:50 p.m.–4:00 p.m.) </li></ul></section>
    </section>
    <section>
        <h2>Friday, June 15: Taking stock</h2>
        <section><h3>Review of XPath applications (9:00 a.m.–12:00 p.m.)</h3><ul><li>Building our syllabus (85 minutes; 9:00 a.m.–10:25 a.m.) <span class="buttons"><button class="localExpand">Expand</button> | <button class="localCollapse">Collapse</button></span><ol>
                    <li>Our schedule in XML:
                            <a href="https://github.com/ebeshero/UpTransformation/blob/master/_includes/schedule/schedule.xml">https://github.com/ebeshero/UpTransformation/blob/master/_includes/schedule/schedule.xml</a><ol>
                            <li>Divided into 5 days: <code>&lt;day d="Monday, June
                                    11"&gt;</code></li>
                            <li>Each day has two slots: <code>&lt;slot
                                    time="10:00:00"&gt;</code></li>
                            <li>Slots have activities: <code>&lt;act time="PT20M"&gt;</code>,
                                    <code>&lt;act time="PT1H30M"&gt;</code></li>
                        </ol></li>
                    <li>How we use XPath in Schematron
                            <a href="https://github.com/ebeshero/UpTransformation/blob/master/_includes/schedule/schedule.sch">https://github.com/ebeshero/UpTransformation/blob/master/_includes/schedule/schedule.sch</a><ol>
                            <li><code>&lt;sch:rule context="slot[1]/@time"&gt;</code><ol>
                                    <li><code>&lt;sch:assert test="if (ancestor::day/@d eq
                                            'Monday, June 11') then . eq '10:00:00' else . eq
                                            '09:30:00'"&gt;Monday starts at 10:00 a.m., other days
                                            at 9:30&lt;/sch:assert&gt;</code></li>
                                </ol></li>
                            <li><code>&lt;sch:rule context="slot[2]/@time"&gt;</code><ol>
                                    <li><code>&lt;sch:assert test=" if (ancestor::day/@d ne
                                            'Friday, June 15') then . eq '13:15:00' else
                                            1"&gt;Afternoon sessions Monday through Thursday start
                                            at 1:15 p.m.&lt;/sch:assert&gt;</code></li>
                                    <li><code>&lt;sch:assert test="ancestor::day/@d ne 'Friday,
                                            June 15'"&gt;There is no afternoon session on
                                            Friday&lt;/sch:assert&gt;</code></li>
                                </ol></li>
                            <li><code>&lt;sch:rule context="slot[1]"&gt;</code><ol>
                                    <li><code>&lt;sch:assert test=" if (../@d eq 'Monday, June
                                            11') then sum(act/@time/xs:dayTimeDuration(.)) eq
                                            xs:dayTimeDuration('PT2H') else
                                            sum(act/@time/xs:dayTimeDuration(.)) eq
                                            xs:dayTimeDuration('PT2H30M')"&gt;Duration of
                                            &lt;sch:value-of
                                            select="sum(act/@time/xs:dayTimeDuration(.))"/&gt; is
                                            incorrect; Monday should be PT2H and other days should
                                            be PT2H30M&lt;/sch:assert&gt;</code></li>
                                </ol></li>
                            <li>
                                <code>&lt;sch:rule context="slot[2]"&gt;</code><ol>
                                    <li><code>&lt;sch:assert test="
                                            sum(act/@time/xs:dayTimeDuration(.)) eq
                                            xs:dayTimeDuration('PT2H35M')"&gt;Duration of
                                            &lt;sch:value-of
                                            select="sum(act/@time/xs:dayTimeDuration(.))"/&gt; is
                                            incorrect; duration of all afternoon sessions should be
                                            PT2H35M&lt;/sch:assert&gt;</code></li>
                                </ol>
                            </li>
                            <li><code>&lt;sch:rule context="title"&gt;</code><ol>
                                    <li><code>&lt;sch:assert
                                            test="string-length(normalize-space(.)) gt 0"&gt;title
                                            must have content&lt;/sch:assert&gt;</code></li>
                                </ol></li>
                        </ol></li>
                    <li>Uses of XPath in XSLT<ol>
                            <li>Customize <code>format-time()</code>
                                 <button class="answer">Answer</button> <div class="answer">&lt;xsl:function name="djb:format-time" as="xs:string"&gt;
    &lt;xsl:param name="input" as="xs:time" required="yes"/&gt;
    &lt;xsl:value-of select="format-time($input, '[h]:[m01] [Pn]')"/&gt;
&lt;/xsl:function&gt;</div></li>
                        </ol></li>
                </ol></li><li>Break (10 minutes; 10:25 a.m.–10:35 a.m.) </li><li>What next? (85 minutes; 10:35 a.m.–12:00 p.m.) </li></ul></section>
    </section>
</section>